# 2017年校招

<!-- TOC -->

- [2017年校招](#2017年校招)
  - [数串](#数串)
    - [思路和难点](#思路和难点)
  - [树的高度](#树的高度)
    - [思路和难点](#思路和难点-1)
  - [句子反转](#句子反转)
    - [思考和难点](#思考和难点)
  - [手机号分身](#手机号分身)
    - [思考和难点](#思考和难点-1)
  - [水仙花数](#水仙花数)
    - [思考与难点](#思考与难点)
  - [数列和](#数列和)
  - [袋鼠过河](#袋鼠过河)
    - [思考和难点](#思考和难点-2)

<!-- /TOC -->

## 数串
[数串](https://github.com/JiangWeixian/Algo/blob/master/%E7%89%9B%E5%AE%A2%E7%BD%912017%E5%B9%B4%E6%A0%A1%E6%8B%9B%E7%9C%9F%E9%A2%98/es6/combineToMaxium.js)

设有n个正整数，将他们连接成一排，组成一个最大的多位整数。

如:n=3时，3个整数13,312,343,连成的最大整数为34331213。

如:n=4时,4个整数7,13,4,246连接成的最大整数为7424613。

### 思路和难点

* `Array.sort` - 关键在于`sort`的回调函数写法

## 树的高度

[deepthOfTree](https://github.com/JiangWeixian/Algo/blob/master/%E7%89%9B%E5%AE%A2%E7%BD%912017%E5%B9%B4%E6%A0%A1%E6%8B%9B%E7%9C%9F%E9%A2%98/es6/deepthOfTree.js)

输入的第一行表示节点的个数n（1 ≤ n ≤ 1000，节点的编号为0到n-1）组成，

下面是n-1行，每行有两个整数，第一个数表示父节点的编号，第二个数表示子节点的编号

```JavaScript
// 输入
5
0 1
0 2
1 3
1 4
// 输出
3
```

### 思路和难点

* 通过输入构建二叉树。**难点在于数字代表节点**。
* 有了二叉树就只需要找到树深度就可以了
  * **树的高度是左边高度或者右边高度，方法是递归！**

## 句子反转

[reverseSentence](https://github.com/JiangWeixian/Algo/blob/master/%E7%89%9B%E5%AE%A2%E7%BD%912017%E5%B9%B4%E6%A0%A1%E6%8B%9B%E7%9C%9F%E9%A2%98/es6/reverseSentence.js)

输入`hello xiao mi`，输出`mi xiao hello`

### 思考和难点

对`JavaScript`来说很容易，不过我知道这是在考**先进后出的概念**，所以我用了`pop()`，没有使用`reverse()`

## 手机号分身 

[phonealias](https://github.com/JiangWeixian/Algo/blob/master/%E7%89%9B%E5%AE%A2%E7%BD%912017%E5%B9%B4%E6%A0%A1%E6%8B%9B%E7%9C%9F%E9%A2%98/es6/phoneAlias.js)

继MIUI8推出手机分身功能之后，MIUI9计划推出一个电话号码分身的功能：首先将电话号码中的每个数字加上8取个位，然后使用对应的大写字母代替 （"ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE"）， 然后随机打乱这些字母，所生成的字符串即为电话号码对应的分身。

```JavaScript
// 输入
4
EIGHT
ZEROTWOONE
OHWETENRTEO
OHEWTIEGTHENRTEO
// 输出
0
234
345
0345
``` 

### 思考和难点

**注意，后面两个字符串是字母级别的打乱顺序**

起初使用正则，就是因为以为是单词级别的打乱。

1. 找到其中单词独有字母
2. 筛选第一步之后，从接下来找剩下数字字母的独有字母，**第一步第二步都是通过计数统计的方式**
3. 第二步和第一步的单词字母可能有重复，所以要再相减那些明确的数字统计

**统计之后，如何换算另说！**

## 水仙花数

* [getDaffodils](https://github.com/JiangWeixian/Algo/blob/master/%E7%89%9B%E5%AE%A2%E7%BD%912017%E5%B9%B4%E6%A0%A1%E6%8B%9B%E7%9C%9F%E9%A2%98/es6/getDaffodils.js)
* [维基百科解释水仙花数](https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0)

对于每个测试实例，要求输出所有在给定范围内的水仙花数，就是说，输出的水仙花数必须大于等于m,并且小于等于n，如果有多个，则要求从小到大排列在一行内输出，之间用一个空格隔开;
如果给定的范围内不存在水仙花数，则输出no;
每个测试实例的输出占一行。

```JavaScript
// 输入
100 120
300 380
// 输出
no
370 371
```

### 思考与难点

把数字像字符串一样分割，然后计算这些是否相等都不是很难。

水仙花难得在优化。这个题目只有`1000`以为，计算量不是很大。  

* 可以缓存每一个位置的次幂值。

**还有其他更好的优化方式，慢慢Google吧..**

## 数列和

[sequenceSum](https://github.com/JiangWeixian/Algo/blob/master/%E7%89%9B%E5%AE%A2%E7%BD%912017%E5%B9%B4%E6%A0%A1%E6%8B%9B%E7%9C%9F%E9%A2%98/es6/sequenceSum.js)

数列的第一项为n，以后各项为前一项的平方根，求数列的前m项的和。

```JavaScript
// 输入
81 4
2 2
// 输出
94.73
3.41
```

没什么难度。

## 袋鼠过河

[jumpRiver]()

一只袋鼠要从河这边跳到河对岸，河很宽，但是河中间打了很多桩子，每隔一米就有一个，每个桩子上都有一个弹簧，袋鼠跳到弹簧上就可以跳的更远。每个弹簧力量不同，用一个数字代表它的力量，如果弹簧力量为5，就代表袋鼠下一跳最多能够跳5米，如果为0，就会陷进去无法继续跳跃。河流一共N米宽，袋鼠初始位置就在第一个弹簧上面，要跳到最后一个弹簧之后就算过河了，给定每个弹簧的力量，求袋鼠最少需要多少跳能够到达对岸。如果无法到达输出-1。

```JavaScript
// 输入
5
2 0 1 1 1
// 输出
4
```

### 思考和难点

刚开始是以下思路：

1. 从所处位置开始，找到能跳范围内最大弹簧力的桩子
2. 到了下一次之后，重复第一步

发现问题在于**这是求组合最优问题。**

**应该是逆向思维!**从对岸终点开始往起点方向找。

1. 从对岸终点**end**开始往起点找，找到一个能跳到终点的**最远桩子B**
2. 然后移动终点**end**到**最远桩子B**。从起点到**最远桩子B**之间，能够跳到终点**end**的最远桩子
3. 重复以上两个步骤


