# 2017年校招

<!-- TOC -->

- [2017年校招](#2017年校招)
  - [数串](#数串)
    - [思路和难点](#思路和难点)
  - [树的高度](#树的高度)
    - [思路和难点](#思路和难点-1)
  - [句子反转](#句子反转)
    - [思考和难点](#思考和难点)
  - [手机号分身](#手机号分身)
    - [思考和难点](#思考和难点-1)
  - [水仙花数](#水仙花数)
    - [思考与难点](#思考与难点)
  - [数列和](#数列和)
  - [袋鼠过河](#袋鼠过河)
    - [思考和难点](#思考和难点-2)
  - [宝石项链](#宝石项链)
    - [思考和难点](#思考和难点-3)
  - [删除得到最大数字](#删除得到最大数字)
  - [思考和难点](#思考和难点-4)

<!-- /TOC -->

## 数串
[数串](https://github.com/JiangWeixian/Algo/blob/master/%E7%89%9B%E5%AE%A2%E7%BD%912017%E5%B9%B4%E6%A0%A1%E6%8B%9B%E7%9C%9F%E9%A2%98/es6/combineToMaxium.js)

设有n个正整数，将他们连接成一排，组成一个最大的多位整数。

如:n=3时，3个整数13,312,343,连成的最大整数为34331213。

如:n=4时,4个整数7,13,4,246连接成的最大整数为7424613。

### 思路和难点

* `Array.sort` - 关键在于`sort`的回调函数写法

## 树的高度

[deepthOfTree](https://github.com/JiangWeixian/Algo/blob/master/%E7%89%9B%E5%AE%A2%E7%BD%912017%E5%B9%B4%E6%A0%A1%E6%8B%9B%E7%9C%9F%E9%A2%98/es6/deepthOfTree.js)

输入的第一行表示节点的个数n（1 ≤ n ≤ 1000，节点的编号为0到n-1）组成，

下面是n-1行，每行有两个整数，第一个数表示父节点的编号，第二个数表示子节点的编号

```JavaScript
// 输入
5
0 1
0 2
1 3
1 4
// 输出
3
```

### 思路和难点

* 通过输入构建二叉树。**难点在于数字代表节点**。
* 有了二叉树就只需要找到树深度就可以了
  * **树的高度是左边高度或者右边高度，方法是递归！**

## 句子反转

[reverseSentence](https://github.com/JiangWeixian/Algo/blob/master/%E7%89%9B%E5%AE%A2%E7%BD%912017%E5%B9%B4%E6%A0%A1%E6%8B%9B%E7%9C%9F%E9%A2%98/es6/reverseSentence.js)

输入`hello xiao mi`，输出`mi xiao hello`

### 思考和难点

对`JavaScript`来说很容易，不过我知道这是在考**先进后出的概念**，所以我用了`pop()`，没有使用`reverse()`

## 手机号分身 

[phonealias](https://github.com/JiangWeixian/Algo/blob/master/%E7%89%9B%E5%AE%A2%E7%BD%912017%E5%B9%B4%E6%A0%A1%E6%8B%9B%E7%9C%9F%E9%A2%98/es6/phoneAlias.js)

继MIUI8推出手机分身功能之后，MIUI9计划推出一个电话号码分身的功能：首先将电话号码中的每个数字加上8取个位，然后使用对应的大写字母代替 （"ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE"）， 然后随机打乱这些字母，所生成的字符串即为电话号码对应的分身。

```JavaScript
// 输入
4
EIGHT
ZEROTWOONE
OHWETENRTEO
OHEWTIEGTHENRTEO
// 输出
0
234
345
0345
``` 

### 思考和难点

**注意，后面两个字符串是字母级别的打乱顺序**

起初使用正则，就是因为以为是单词级别的打乱。

1. 找到其中单词独有字母
2. 筛选第一步之后，从接下来找剩下数字字母的独有字母，**第一步第二步都是通过计数统计的方式**
3. 第二步和第一步的单词字母可能有重复，所以要再相减那些明确的数字统计

**统计之后，如何换算另说！**

## 水仙花数

* [getDaffodils](https://github.com/JiangWeixian/Algo/blob/master/%E7%89%9B%E5%AE%A2%E7%BD%912017%E5%B9%B4%E6%A0%A1%E6%8B%9B%E7%9C%9F%E9%A2%98/es6/getDaffodils.js)
* [维基百科解释水仙花数](https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0)

对于每个测试实例，要求输出所有在给定范围内的水仙花数，就是说，输出的水仙花数必须大于等于m,并且小于等于n，如果有多个，则要求从小到大排列在一行内输出，之间用一个空格隔开;
如果给定的范围内不存在水仙花数，则输出no;
每个测试实例的输出占一行。

```JavaScript
// 输入
100 120
300 380
// 输出
no
370 371
```

### 思考与难点

把数字像字符串一样分割，然后计算这些是否相等都不是很难。

水仙花难得在优化。这个题目只有`1000`以为，计算量不是很大。  

* 可以缓存每一个位置的次幂值。

**还有其他更好的优化方式，慢慢Google吧..**

## 数列和

[sequenceSum](https://github.com/JiangWeixian/Algo/blob/master/%E7%89%9B%E5%AE%A2%E7%BD%912017%E5%B9%B4%E6%A0%A1%E6%8B%9B%E7%9C%9F%E9%A2%98/es6/sequenceSum.js)

数列的第一项为n，以后各项为前一项的平方根，求数列的前m项的和。

```JavaScript
// 输入
81 4
2 2
// 输出
94.73
3.41
```

没什么难度。

## 袋鼠过河

[jumpRiver](https://github.com/JiangWeixian/Algo/blob/master/%E7%89%9B%E5%AE%A2%E7%BD%912017%E5%B9%B4%E6%A0%A1%E6%8B%9B%E7%9C%9F%E9%A2%98/es6/jumpRiver.js)

一只袋鼠要从河这边跳到河对岸，河很宽，但是河中间打了很多桩子，每隔一米就有一个，每个桩子上都有一个弹簧，袋鼠跳到弹簧上就可以跳的更远。每个弹簧力量不同，用一个数字代表它的力量，如果弹簧力量为5，就代表袋鼠下一跳最多能够跳5米，如果为0，就会陷进去无法继续跳跃。河流一共N米宽，袋鼠初始位置就在第一个弹簧上面，要跳到最后一个弹簧之后就算过河了，给定每个弹簧的力量，求袋鼠最少需要多少跳能够到达对岸。如果无法到达输出-1。

```JavaScript
// 输入
5
2 0 1 1 1
// 输出
4
```

### 思考和难点

刚开始是以下思路：

1. 从所处位置开始，找到能跳范围内最大弹簧力的桩子
2. 到了下一次之后，重复第一步

发现问题在于**这是求组合最优问题。**

**应该是逆向思维!**从对岸终点开始往起点方向找。

1. 从对岸终点**end**开始往起点找，找到一个能跳到终点的**最远桩子B**
2. 然后移动终点**end**到**最远桩子B**。从起点到**最远桩子B**之间，能够跳到终点**end**的最远桩子
3. 重复以上两个步骤

## 宝石项链

[necklaceFive](https://github.com/JiangWeixian/Algo/blob/master/%E7%89%9B%E5%AE%A2%E7%BD%912017%E5%B9%B4%E6%A0%A1%E6%8B%9B%E7%9C%9F%E9%A2%98/es6/necklaceFive.js)

有一条彩色宝石项链，是由很多种不同的宝石组成的，包括红宝石，蓝宝石，钻石，翡翠，珍珠等。喜欢红宝石，蓝宝石，紫水晶，翡翠和钻石这五种，我要你从项链中截取**连续**的一小段还给我，这一段中必须包含所有的这五种宝石，剩下的部分你可以带走。**如果无法**找到则一个也无法带走。**我们用每种字符代表一种宝石，A表示红宝石，B表示蓝宝石，C代表紫水晶，D代表翡翠，E代表钻石，F代表玉石，G代表玻璃等等**

```JavaScript
// 输入
ABCYDYE
ATTMBQECPD
// 输出
1
3
```

### 思考和难点

用了比较蠢的方法，原谅我没有找到更好的。

* 关键在于项链是首尾相连的，所以用了**链表的知识，为了更好处理，链表存储和指向都是`index`**
* 初始化`start`，然后遍历之后所有点**注意是循环链接的**，找到`[A, B, C, D, E]`内任意一个就将该字母从`[A, B, C, D, E]`。
* 如果找到五个了，就保留此时的`start`以及此时的`index`位置。并跳出当前循环。

**想要拿到最短的，截取的那一段就必须是首尾巴都是`[A, B, C, D, E]`内部宝石。**

## 删除得到最大数字

[splice2biggest](https://github.com/JiangWeixian/Algo/blob/master/%E7%89%9B%E5%AE%A2%E7%BD%912017%E5%B9%B4%E6%A0%A1%E6%8B%9B%E7%9C%9F%E9%A2%98/es6/spliceTobiggest.js)

给定一个十进制的正整数number，选择从里面去掉一部分数字，希望保留下来的数字组成的正整数最大。

```JavaScript
// 输入
325 1
// 输出
35

// 输入
5175873 2
// 输出
75873
```

## 思考和难点

注意不要犯的错误是：**并没有要求是连续的删除两个数字**。

* 其实**相当于移动位置**，将数字较大的位置前移，替换掉原来位置的数字
* 还需要考虑删除的数字数目不够的情况（**此时可以得到结论，此时数字的排序是前面的比较大，后面的比较小，所以删除后面就可以了。**）
